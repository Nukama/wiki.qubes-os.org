<h1 id="QubesSplitGPG">Qubes Split GPG</h1>
<h2 id="WhatisSplitGPGandwhyshouldIuseitinsteadofthestandardGPG">What is Split GPG and why should I use it instead of the standard GPG?</h2>
<p>Split GPG implements a concept similar to having a smart card with your private GPG keys, except that the role of the &quot;smart card&quot; plays another Qubes AppVM. This way one, not-so-trusted domain, e.g. the one where Thunderbird is running, can delegate all crypto operations, such as encryption/decryption and signing to another, more trusted, network-isolated, domain. This way a compromise of your domain where the Thunderbird or other client app is running -- arguably a not-so-unthinkable scenario -- does not allow the attacker to automatically also steal all your keys (we should make a rather obvious comment here that the so-often-used passphrases on private keys are pretty meaningless because the attacker can easily set up a simple backdoor which would wait until the user enters the passphrase and steal the key then).</p>
<p>The diagram below presents the big picture of Split GPG architecture.</p>
<p><a href="/wiki/attachment/wiki/UserDoc/SplitGpg/split-gpg-diagram.png"><img src="/wiki/chrome/common/attachment.png" title="No image &quot;split-gpg-diagram.png&quot; attached to UserDoc/SplitGpg" alt="No image &quot;split-gpg-diagram.png&quot; attached to UserDoc/SplitGpg" /></a></p>
<h3 id="AdvantagesofSplitGPGvs.traditionalGPGwithasmartcard">Advantages of Split GPG vs. traditional GPG with a smart card</h3>
<p>It is often thought that the use of smart cards for private key storage guarantees ultimate safety. While this might be true (unless the attacker can find a usually-very-expensive-and-requiring-physical-presence way to extract the key from the smart card) but only with regards to the safety of the private key itself. However, there is usually nothing that could stop the attacker from requesting the smart card to perform decryption of all the user documents the attacker has found or need to decrypt. In other words, while protecting the user's private key is an important task, we should not forget that ultimately it is the user data that are to be protected and that the smart card chip has no way of knowing the requests to decrypt documents are now coming from the attacker's script and not from the user sitting in front of the monitor. (Similarly the smart card doesn't make the process of digitally signing a document or a transaction in any way more secure -- the user cannot know what the chip is really signing. Unfortunately this problem of signing reliability is not solvable by Split GPG)</p>
<p>With Qubes Split GPG this problem is drastically minimized, because each time the key is to be used the user is asked for consent (with a definable time out, 5 minutes by default), plus is always notified each time the key is used via a tray notification from the domain where GPG backend is running. This way it would be easy to spot unexpected requests to decrypt documents.</p>
<p><a href="/wiki/attachment/wiki/UserDoc/SplitGpg/r2-split-gpg-1.png"><img src="/wiki/chrome/common/attachment.png" title="No image &quot;r2-split-gpg-1.png&quot; attached to UserDoc/SplitGpg" alt="No image &quot;r2-split-gpg-1.png&quot; attached to UserDoc/SplitGpg" /></a> <a href="/wiki/attachment/wiki/UserDoc/SplitGpg/r2-split-gpg-3.png"><img src="/wiki/chrome/common/attachment.png" title="No image &quot;r2-split-gpg-3.png&quot; attached to UserDoc/SplitGpg" alt="No image &quot;r2-split-gpg-3.png&quot; attached to UserDoc/SplitGpg" /></a></p>
<h3 id="Currentlimitations">Current limitations</h3>
<ul>
<li>Current implementation requires importing of public keys to the vault domain. This opens up an avenue to attack the gpg running in the backend domain via a hypothetical bug in public key importing code. See ticket #474 for more details and plans how to get around this problem, as well as the section on <a href="/wiki/wiki/UserDoc/SplitGpg#Advanced:UsingSplitGPGwithSubkeys">using split GPG with subkeys</a> below.</li>
</ul>
<p></p>
<ul>
<li>It doesn't solve the problem of allowing the user to know what is to be signed before the operation gets approved. Perhaps the GPG backend domain could start a Disposable VM and have the to-be-signed document displayed there? To Be Determined.</li>
</ul>
<h2 id="ConfiguringandusingSplitGPG">Configuring and using Split GPG</h2>
<p>Start with creating a dedicated AppVM for storing your keys (the GPG backend domain). It is recommended that this domain be network disconnected (set its netvm to <code>none</code>) and only used for this one purpose. In later examples this AppVM is named <code>work-gpg</code>, but of course it might have any other name.</p>
<h3 id="SettinguptheGPGbackenddomain">Setting up the GPG backend domain</h3>
<p>Make sure the gpg is installed there and there are some private keys in the keyring, e.g.:</p>
<pre class="wiki"><code>[user@work-gpg ~]$ gpg -K
/home/user/.gnupg/secring.gpg
-----------------------------
sec   4096R/3F48CB21 2012-11-15
uid                  Qubes OS Security Team &lt;security@qubes-os.org&gt;
ssb   4096R/30498E2A 2012-11-15
(...)</code></pre>
<p>This is pretty much all that is required. However one might also want to modify the default timeout which tells the backend for how long the user's approval for key access should be valid (default 5 minutes). This is adjustable via <code>QUBES_GPG_AUTOACCEPT</code> variable. One can override it e.g. in <code>~/.bash_profile</code>:</p>
<pre class="wiki"><code>[user@work-gpg ~]$ echo &quot;export QUBES_GPG_AUTOACCEPT=86400&quot; &gt;&gt; ~/.bash_profile</code></pre>
<h3 id="ConfiguringtheclientappstousesplitGPGbackend">Configuring the client apps to use split GPG backend</h3>
<p>Normally it should be enough to set the <code>QUBES_GPG_DOMAIN</code> to the GPG backend domain name and use <code>qubes-gpg-client</code> in place of <code>gpg</code>, e.g.:</p>
<pre class="wiki"><code>[user@work ~]$ export QUBES_GPG_DOMAIN=work-gpg
[user@work ~]$ gpg -K
[user@work ~]$ qubes-gpg-client -K
/home/user/.gnupg/secring.gpg
-----------------------------
sec   4096R/3F48CB21 2012-11-15
uid                  Qubes OS Security Team &lt;security@qubes-os.org&gt;
ssb   4096R/30498E2A 2012-11-15
(...)

[user@work ~]$ qubes-gpg-client secret_message.txt.asc 
(...)</code></pre>
<p>Note that running normal <code>gpg -K</code> in the demo above shows no private keys stored in this AppVM.</p>
<h3 id="ConfiguringThunderbirdEnigmailforusewithSplitGPG">Configuring <a href="/wiki/wiki/UserDoc/Thunderbird/Enigmail">Thunderbird/Enigmail?</a> for use with Split GPG</h3>
<p>However, when using Thunderbird with Enigmail extension it is not enough, because Thunderbird doesn't preserve the environment variables. Instead it is recommended to use a simple script provided by <code>/usr/bin/qubes-gpg-client-wrapper</code> file by pointing Enigmail to use this script instead of the standard GnuPG binary:</p>
<p><a href="/wiki/attachment/wiki/UserDoc/SplitGpg/tb-enigmail-split-gpg-settings-2.png"><img src="/wiki/chrome/common/attachment.png" title="No image &quot;tb-enigmail-split-gpg-settings-2.png&quot; attached to UserDoc/SplitGpg" alt="No image &quot;tb-enigmail-split-gpg-settings-2.png&quot; attached to UserDoc/SplitGpg" /></a></p>
<p>The script also sets the QUBES_GPG_DOMAIN variable automatically based on the content of the file <code>/rw/config/gpg-split-domain</code>, which should be set to the name of the GPG backend VM. This file survives the AppVM reboot, of course.</p>
<pre class="wiki"><code>[user@work ~]$ sudo bash
[user@work ~]$ echo &quot;work-gpg&quot; &gt; /rw/config/gpg-split-domain</code></pre>
<p><em>NOTE</em>: A recent engimail update, version <code>thunderbird-enigmail-1.7-1</code>, introduced changes in how Enigmail expects to execute GPG binary and so requires an updated split-gpg package with version &gt;= <code>qubes-gpg-split-2.0.7-1</code>. Please make sure you have all the latest qubes packages installed in your template.</p>
<h3 id="Importingpublickeys">Importing public keys</h3>
<p>Use <code>qubes-gpg-import-key</code> in the client AppVM to import the key into the GPG backend VM. Of course a (safe, unspoofable) user consent dialog box is displayed to accept this.</p>
<pre class="wiki"><code>[user@work ~]$ export QUBES_GPG_DOMAIN=work-gpg
[user@work ~]$ qubes-gpg-import-key ~/Downloads/marmarek.asc</code></pre>
<p><a href="/wiki/attachment/wiki/UserDoc/SplitGpg/r2-split-gpg-5.png"><img src="/wiki/chrome/common/attachment.png" title="No image &quot;r2-split-gpg-5.png&quot; attached to UserDoc/SplitGpg" alt="No image &quot;r2-split-gpg-5.png&quot; attached to UserDoc/SplitGpg" /></a></p>
<h2 id="Advanced:UsingSplitGPGwithSubkeys">Advanced: Using Split GPG with Subkeys</h2>
<p>Users with particularly high security requirements may wish to use split GPG with <a href="https://wiki.debian.org/Subkeys">â€‹subkeys</a>. However, this setup comes at a significant cost: It will be impossible to sign other people's keys without breaking this security model. Nonetheless, if signing others' keys is not required, then split GPG with subkeys offers unparalleled security for one's master secret key.</p>
<h3 id="SetupDescription">Setup Description</h3>
<p>In this example, the following keys are stored in the following locations:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>PGP Key(s)</strong></td>
<td style="text-align: left;"><strong>VM Name</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">master secret key</td>
<td style="text-align: left;">vault</td>
</tr>
<tr class="odd">
<td style="text-align: left;">secret subkeys</td>
<td style="text-align: left;">work-gpg</td>
</tr>
<tr class="even">
<td style="text-align: left;">public key</td>
<td style="text-align: left;">work-email</td>
</tr>
</tbody>
</table>
<dl>
<dt>master secret key (sec)</dt>
<dd>It is recommended that this key be created as a <strong>certify-only (C)</strong> key, i.e., a key which is capable only of signing other keys. This key may be created <em>without</em> an expiration date. This is for two reasons. First, the master secret key is never to leave the vault VM, so it is extremely unlikely ever to be obtained by an adversary (see below). Second, an adversary who <em>does</em> manage to obtain the master secret key either possesses the passphrase to unlock the key, or he does not. If he does, then he can simply use the passphrase in order to legally extend the expiration date of the key (or remove it entirely). If he does not, then he cannot use the key. In either case, an expiration date provides no additional benefit. It is, however, recommended that a <strong>revocation certificate</strong> be created so that the master keypair may be revoked in the (exceedingly unlikely) event that an adversary obtains both the master secret key <em>and</em> the passphrase. It is recommended that the master secret key passphrase only ever be input in the vault VM. (Subkeys should use a different passphrase; see below).
</dd>
</dl>
<dl>
<dt>secret subkeys (ssb)</dt>
<dd>It is recommended that two subkeys be created: one for <strong>signing (S)</strong>, and one for <strong>encryption (E)</strong>. It is further recommended that a <em>different</em> passphrase be used for these subkeys than for the master secret key. Finally, it is recommended that each of these subkeys be created with a reasonable expiration date (e.g., one year), and that a <em>new</em> set of subkeys be created whenever the existing set expires, rather than the expiration date of the existing keys being extended. This is because an adversary who obtains any existing encryption subkey (for example) will be able to use it in order to decrypt all emails (for example) which were encrypted with that subkey. If the same subkey were to continue to be used--and its expiration date continually extended--only that one key would need to be stolen (e.g., as a result of the work-gpg VM being compromised; see below) in order to decrypt <em>all</em> of the user's emails. If, on the other hand, each encryption subkey is used for at most approximately one year, then an adversary who obtains the secret subkey will be capable of decrypting at most approximately one year's worth of emails.
</dd>
</dl>
<dl>
<dt>public key (pub)</dt>
<dd>This is the complement of the master secret key. It should be uploaded to keyservers and may be signed by others.
</dd>
</dl>
<dl>
<dt>vault</dt>
<dd>This is a network-isolated VM. The initial master keypair and subkeys are generated in this VM. The master secret key <em>never</em> leaves this VM under <em>any</em> circumstances. No files or text is <em>ever</em> copied or transferred into this VM under <em>any</em> circumstances.
</dd>
</dl>
<dl>
<dt>work-gpg</dt>
<dd>This is a network-isolated VM. This VM is used <em>only</em> as the GPG backend for work-email. The secret subkeys (but <em>not</em> the master secret key) are <a href="/wiki/wiki/CopyingFiles">copied</a> from the vault VM to this VM. Files from less trusted VMs are <em>never</em> copied or transferred into this VM under <em>any</em> circumstances.
</dd>
</dl>
<dl>
<dt>work-email</dt>
<dd>This VM has access to the mail server. It accesses the work-gpg VM via the split GPG protocol. The public key may be stored in this VM so that it can be attached to emails and for other such purposes.
</dd>
</dl>
<h3 id="SecurityBenefits">Security Benefits</h3>
<p>In the standard split GPG setup, there are at least two ways in which the work-gpg VM might be compromised. First, an attacker who is capable of exploiting a hypothetical bug in work-email's <a href="https://en.wikipedia.org/wiki/Mail_user_agent">â€‹MUA</a> could send a malformed request which exploits a hypothetical bug in the GPG backend (running in the work-gpg VM), giving the attacker control of the work-gpg VM. Second, a malicious public key file which is imported to the work-gpg VM might exploit a hypothetical bug in the GPG backend which is running there, giving the attacker control of work-gpg. In either case, such an attacker might then be able to leak both the master secret key and its passphrase (which is regularly input in the work-gpg VM and is therefore easily obtained by the attacker) back to work-email or to another VM (e.g., the netvm) via the split GPG protocol or other <a href="/wiki/wiki/DataLeaks">covert channels</a>.</p>
<p>In the alternative setup described in this section (i.e., the subkey setup), even an attacker who manages to gain control of the work-gpg VM will not be able to obtain the user's master secret key without a general Xen VM escape exploit, since the master secret key is not present in the work-gpg VM. Rather, the master secret key remains in the vault VM (which, in the absence of a general Xen VM escape exploit, is assumed not to be compromised, since nothing is ever copied or transferred into it). The attacker might be able to leak the secret subkeys from the work-gpg VM in the manner described above, but even if the attacker is successful, the master secret key can simply be used to revoke the compromised subkeys and to issue new subkeys in their place.</p>
<h3 id="SubkeyTutorialsandDiscussions">Subkey Tutorials and Discussions</h3>
<p>(Note: Although the tutorials below were not written with Qubes Split GPG in mind, they can be adapted with a few commonsense adjustments. As always, exercise caution and use your good judgment.)</p>
<ul>
<li><a href="https://groups.google.com/d/topic/qubes-users/Kwfuern-R2U/discussion">â€‹&quot;OpenPGP in Qubes OS&quot; on the qubes-users mailing list</a></li>
<li><a href="https://alexcabal.com/creating-the-perfect-gpg-keypair/">â€‹&quot;Creating the Perfect GPG Keypair&quot; by Alex Cabal</a></li>
<li><a href="https://gist.github.com/abeluck/3383449">â€‹&quot;GPG Offline Master Key w/ smartcard&quot; maintained by Abel Luck</a></li>
<li><a href="https://apapadop.wordpress.com/2013/08/21/using-gnupg-with-qubesos/">â€‹&quot;Using GnuPG with QubesOS&quot; by Alex</a></li>
</ul>
